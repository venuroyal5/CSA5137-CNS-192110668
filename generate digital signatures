#include <stdio.h>
// Function to compute the greatest common divisor (gcd) of two numbers
int gcd(int p, int q) {
 if (q == 0)
 return p;
 else
 return gcd(q, p % q);
}
// Function to compute the multiplicative inverse using the extended Euclidean algorithm
int exteuclid(int a, int b) {
 int r_1 = a, r_2 = b, s_1 = 1, s_2 = 0, t_1 = 0, t_2 = 1;
 int temp, r, s, t;
 while (r_2 > 0) {
 temp = r_1 / r_2;
 r = r_1 - temp * r_2;
 r_1 = r_2;
 r_2 = r;
 s = s_1 - temp * s_2;
 s_1 = s_2;
 s_2 = s;
 t = t_1 - temp * t_2;
 t_1 = t_2;
 t_2 = t;
 }
 if (t_1 < 0)
 t_1 = t_1 + a;
 return t_1;
}
// Function to perform modular exponentiation
int mod_exp(int base, int exp, int mod) {
 int result = 1;
 while (exp > 0) {
 if (exp % 2 == 1)
 result = (result * base) % mod;
 base = (base * base) % mod;
 exp = exp / 2;
 }
 return result;
}
int main() {
 int p = 823, q = 953;
 int n = p * q;
 int Pn = (p - 1) * (q - 1);
 int possible_key[Pn];
 int count = 0;
 // Generate possible encryption keys
 for (int i = 2; i < Pn; i++) {
 if (gcd(Pn, i) == 1) {
 possible_key[count++] = i;
 }
 }
 // Select encryption key and compute its multiplicative inverse
 int e = -1;
 int d;
 for (int i = 0; i < count; i++) {
 d = exteuclid(Pn, possible_key[i]);
 if (d > 0) {
 e = possible_key[i];
 break;
 }
 }
 if (e == -1) {
 printf("No possible encryption key!\n");
 return 1;
 }
 printf("Encryption Key is: %d\n", e);
 printf("Decryption Key is: %d\n", d);
 // Message sent by Andy
 int M = 14123;
 // Signature created by Andy
 int S = mod_exp(M, d, n);
 // Message generated by Bert using the signature and Andy's public key
 int M1 = mod_exp(S, e, n);
 // Verification
 if (M == M1) {
 printf("As M == M1, the Message is Accepted and the sender is verified as Andy!\n");
 } else {
 printf("As M not equal to M1, the message is rejected!\n");
 }
 return 0;
}
